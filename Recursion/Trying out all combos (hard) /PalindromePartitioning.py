'''

Problem Statement: You are given a string s, partition it in such a way that every substring is a palindrome. Return all such palindromic partitions of s.

Example 1:

Input: s = “aab”

Output: [ ["a","a","b"], ["aa","b"] ]	

Explanation: The first  answer is generated by  making three partitions. The second answer is generated by making two partitions.

Example 2:

Input: s = “aabb”

Output: [ [“a”,”a”,”b”,”b”], [“aa”,”bb”], [“a”,”a”,”bb”], [“aa”,”b”,”b”] ] 

Approach:

Partition the string using an index starting at 0, loop through the given string to divide a string from i to index. Check if the divided string is palindrome or not before partitioning.

'''

class Solution:
    def isPalindrome(s, start, end):
        while start <= end:
            if s[start] != s[end]:
                return False
            start += 1
            end -= 1
        return True
    def partition(self, s: str) -> List[List[str]]:
        
        res = []
        ds = []

        def helper(index):
            if index == len(s):
                res.append(ds[:])
                return
            
            for i in range(index, len(s)):
                if Solution.isPalindrome(s, index, i):
                    ds.append(s[index:i+1])
                    helper(i+1)
                    ds.pop()
            
        helper(0)
        return res

'''

Time Complexity: O( (2^n) *k*(n/2) )

Reason: O(2^n) to generate every substring and O(n/2)  to check if the substring generated is a palindrome. O(k) is for inserting the palindromes in another data structure, 
where k  is the average length of the palindrome list.

Space Complexity: O(k * x)

Reason: The space complexity can vary depending upon the length of the answer. k is the average length of the list of palindromes and if we have x such list of palindromes in our final answer. 
The depth of the recursion tree is n, so the auxiliary space required is equal to the O(n).


'''
